User
  userid
  password
  name
  email

Bid
  bid-id
  userid
  auctionid
  timestamp
  price
  valid
  cancellation time

Auction
  auction-id
  userid
  description
  start
  expiration
  notes
  increment
  reserve
  startPrice

Bidder
  userid
  password

  register
  determine bid

Auctioneer
  register
  terminate auction

  login
  search
  increment
  price quote
  time remaining
  submit bid
  logoff




Auctioneer
  database
  login
  price quote
  increment
  time remaining
  submit bid
  logoff

Notification
  id
  userid
  message
  datetime




Users:
  name
  nos:
  id

Customer
  name:
  no
  id
  object_name
  bidding_amount:
  search
  bid

Client
  name
  nos:
  object_name
  string
  time_limit
  host_auction
  track_of_payment



Bid:
  current_bid:
  maximum_bid:
  sort_bidding_amount()


Payment
  Amount:

Users:
  name:
  nos
  id

Buyer
  name
  no
  id
  object_name
  bidding_amount


Seller
  name:
  nos
  id
  object_name
  base_price
  time_limit
  host_auction
  set_bidding_details

Object
  name
  description
  start_bid
  last_bid
  current_biddder
  status
  category

Admin
  username
  password
  blocking
  notification
  ownership_of_object
  transfer_of_amount
  track_of_payment

Bid
  current_bid
  maximum_bid

Payment
  Amount


class AggregateRoot:
  def check_rule(...):
    ...

class Listing(Entity):
  """A class representing an item for sale"""
  status: ListingStatus = ListingStatus.Draft

  def publish():
    self.status = ListingStatus.Published

  def unpublish():
    self.status = ListingStatus.Draft


class Seller(AggregateRoot):
  """A class representing a seller willing to list a listing"""
  id: UUID
  published_listings_count: int = 0

  def publish_listing(self, listing: Listing):
    """This method is a part of a public Seller API"""
    #Validate listing
    self.check_rule(ListingPriceMustBeGreaterThanZero(listing))
    self.check_rule(ListingMustBeDraft(listing))
    #do some business logic
    listing.publish()
    self.published_listings_count += 1
    # check aggregate invariants
    self.check_rule(SellerCanHaveUpToThreeListingsInTheCatalog(self.published_listings_count))




Where should i put logic concerning two or more aggregates?
Sometimes the business logic spans multiple aggregates. A common
scenario here is to ensure uniqueness. Lets' we have a User entity in our system. The business are as following.

1. User can change it's username, but no more that once a month
   (3o days)
2. Username of a User must by uniwue within a system.

The first rule can be easily check within an aggregate:

class User(AggregateRoot):
  id: UUID
  username: str
  username_changed_at: date

  def change_username(username: str):
    self.check_rule(UsernameCanBeChangedAtMostOnceAMonth(self.username_changed_count))
    self.username = username

But how we can guarantee the uniqueness of a new username?
i think the only plausible choice here is to use the Domain Service.
We could create a UsernameUniquenessChecker domain service to handle the job:


class UsernameUniquenessChecker:
  def __init__(self, user_repository):
    self.user_repository = user_repository

  def is_unique(username: str) -> bool:
    if self.user_repository.find_user_by_username(username):
      #user with this username exists, so it's not unique
      return False
    return True


class User(AggregateRoot):
  id: UUID
  username: str
  username_changed_at: date

  def change_username(username: str, username_uniqueness_checker: UsernameUniquenessChecker):
    self.check_rule(UsernameCanBeChangedAtMostOnceAMonth(self.username_changed_at))
    if not username_uniqueness_checker.is_unique(username):
      raise BusinessRuleValidationException("Username must be unique")
    self.username = username


TODO for near future:
>Simple authorization (user id in request header)
>First business use-case (upt to three open times at the same time)
>Application-level exceptions for invalid commands
>Tests!!!! +code metrics + CI/CD
>Executing commands with immediate feedback
 http://blog.sapiensworks.com/post/2015/07/20/CQRS-Immediate-Feedback-Web-App

>handling commands erros: application layer, business layer
>Command validation
 https://stackoverflow.com/questions/32239583/command-validation-in-ddd-with-cqrs

>handling async commands (mediator pattern, asyncio)
>Application-level event bus, publisehr/subscriber pattern
>Framework agnostic integration tests??


User Stories:
>>As a seller i can list a new item for sale.
  The item has the following fields: texts, description, starting price
>>As a seller, I'm allowed to list up to 3 times at the same time



Implementing Value Objects in Python


A value Object is one of the fundametal building blocks
of Domain-Driven Design. It is small object (in terms memory),
which consists of one or more attributes, and which represents a conceptual
whole. Value Object is usually a part of Entity.


Some examples of value objects are: Email (consisting of a single email attribute),
Money (consisting of amount and currency),
DateRange (consisting of a start date, and an end date).
GPSCoordinates(made of latitude and logitude),
Address(consisting of a street, zip code, city, state, etc.)
Apart from the attributes, all of the above
can (and should include some kind of validation logic too.)


Value objects do not have an identity - they
are simply a collection of attributes that are related
to each other.

Here are the most important properties of a value object.
1. Its state is immutable. Once created, the state of a value object cannot be changed.
2. It is distinguishable only by the state of its attributes. Two instant
   with the same attribute values are considered to be equal (this is also known
   as structural equality)
3. It should encapsulate business logic that prevents us from
   constructing a value object with an invalid state (ie. start date < end date for a date range.)
4. All methods of a value object should be pure.i.e calling a method
   does not trigger any side effects or change the state of a value objects
   However, returning a new instance that reflects the changes is fine.
5. It should be easy to unit-test a value object and it should be
   easy to reason about its logic.



Let's implement a DateRange value object using Python dataclasses
module.


from dataclasses import dataclass
from datetime import datetime



class BusinessRuleValidationException(Exception):
  """A base class for all business rule validation"""


class ValueObject:
  """A base class for all value objects"""

@dataclass(frozen=True)
class DateRange(ValueObject):
  """Our first value object"""
  start_date: date
  end_date: date

  def __post_init__(self):
    """Here we check if a value object has a value state."""
    if not self.start_date < self.end_date:
      raise BusinessRuleValidationException("end date should be greater than start date")
  def days(self):
    """Returns the number of days between the start date and the end date"""
    delta = self.end_date - self.start_date + timedelta(days=1)
    return delta.days

  def extend(self, days):
    """Extend the end date by a specified number of days"""
    new_end_date = self.end_date + timedelta(days=days)
    return DateRange(self.start_date, new_end_date)


To guarantee immutability of a DateRange, we are using
@dataclass(frozen=True) decorator.




import unittest

class DateRangeTestCase(unittest.TestCase):
  def test_equality(self):
    range1 = DateRange(start_date=(2020,1,1), end_date=(2021, 1, 1))
    range2 = DateRange(start_date=(2020,1,1), end_date=(2021, 1, 1))
    self.assertEqual(range1, range2)

  def test_days(self):
    range = DateRange(start_date=date(2020, 1, 1), end_date=(2020, 1, 1))
    self.assertEqual(range.days(), 1)

  def test_days(self):
    range1 = DateRange(start_date=date(2020, 1, 1), end_date=(2020, 1, 1))
    range2 = range1.extend(days=1)
    self.assertEqual(range2, DateRange(start_date=(2020,1,1), end_date=(2021, 1, 2)))

  def test_cannot_create_invalid_date_range(self):
    with self.assertRaises(BusinessRuleValidationException):
      DateRange(start_date=date(2021, 1, 1), end_date=date(2020,1,1))


